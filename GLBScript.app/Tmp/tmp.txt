//$$RESETFILE.\JumpIt.gbas
// --------------------------------- //
// Project: JumpIt
// Start: Sunday, September 25, 2011
// IDE Version: 10.118

// viele Level
// Einspieler Modus
// 4 Gegnertypen
// Pixelgrafik (Paint.NET)
// Levelwechsel
// Leiter
// Stacheln
// Startpunkt
// Trampolin
// Mapeditor
// Bomben + Schalter


//Gegner
// 1) Schwein (geht)
// 2) Vogel (fliegt, kackt)
// 3) Fetter Mensch (der rollt/überrollt)
// 4) Llama (spuckt)

?OPTIMIZE NONE

LIMITFPS 30
GLOBAL Hardware$ = PLATFORMINFO$("DEVICE")
 LOCAL dx%, dy%
GETDESKTOPSIZE dx, dy

SYSTEMPOINTER TRUE

IF Hardware$ = "DESKTOP"
	dx = 800
	dy = 600
ENDIF

SETSCREEN dx, dy, FALSE
IF dx < dy
	IF Hardware$ <> "DESKTOP" OR Hardware$ = "WIZ"
		SETORIENTATION 1
	ENDIF
ENDIF

SETCURRENTDIR("Media") // go to media files

CONSTANT STATE_IS_GAME = 0

GLOBAL Gamestate% = STATE_IS_GAME
GLOBAL EditorEnemy AS TEnemy
GLOBAL SelectTile% = 0
GLOBAL MouseX, MouseY, ML, MR

//LOADFONT "smalfont.png", 0
//LOADFONT "smalfont2.png", 1
//SETFONT 0

GLOBAL PlayerImage%
PlayerImage = GENSPRITE()
LOADANIM "spieler.png", PlayerImage, 16, 32

//GLOBAL BGImage%
//BGImage = GENSPRITE()
//LOADSPRITE "bg.png", BGImage

GLOBAL LadderImage%
LadderImage = GENSPRITE()
LOADSPRITE "leiter.png", LadderImage

GLOBAL SpikeImage%
SpikeImage = GENSPRITE()
LOADSPRITE "stachel.png", SpikeImage

GLOBAL TrampolineImage%
TrampolineImage = GENSPRITE()
LOADSPRITE "trampolin.png", TrampolineImage

GLOBAL PigImage%
PigImage = GENSPRITE()
LOADANIM "schwein.png", PigImage, 32, 32

GLOBAL HumanImage%
HumanImage = GENSPRITE()
LOADSPRITE "fettmonster.png", HumanImage

GLOBAL BirdImage%
BirdImage = GENSPRITE()
LOADANIM "vogel.png", BirdImage, 32, 16

GLOBAL ShitImage%
ShitImage = GENSPRITE()
LOADSPRITE "exkrement.png", ShitImage

GLOBAL LlamaImage%
LlamaImage = GENSPRITE()
LOADANIM "llama.png", LlamaImage, 46, 64

GLOBAL SpitImage%
SpitImage = GENSPRITE()
LOADSPRITE "spucke.png", SpitImage

GLOBAL DoorImage%
DoorImage = GENSPRITE()
LOADSPRITE "tuer.png", DoorImage

GLOBAL TriggerImage%
TriggerImage = GENSPRITE()
LOADANIM "schalter.png", TriggerImage, 32, 16

GLOBAL DynamitImage%
DynamitImage = GENSPRITE()
LOADSPRITE "dynamit.png", DynamitImage

GLOBAL ExplosionImage%
ExplosionImage = GENSPRITE()
LOADANIM "explosion.png", ExplosionImage, 32, 32

GLOBAL MenuImage%
MenuImage = GENSPRITE()
LOADSPRITE "menu.png", MenuImage

GLOBAL ButtonImage%
ButtonImage = GENSPRITE()
LOADSPRITE "button.png", ButtonImage

GLOBAL ArrowImage%
ArrowImage = GENSPRITE()
LOADSPRITE "pfeil.png", ArrowImage

GLOBAL JumpImage%
JumpImage = GENSPRITE()
LOADSPRITE "springen.png", JumpImage


GLOBAL Player AS TPlayer //"erstellt" den Spieler.
GLOBAL Map AS TMap

CLEARSCREEN RGB(63,156,255)

GOSUB Init
Title$ = "JumpIt Spielmenue"
Menu1$ = "Spielen"
Menu2$ = "Mapeditor"
Menu3$ = "Beenden"
PUSHLOOP "MENU_LOOP"

GLOBAL LastMousePosition%[]



SUB GLB_ON_LOOP:
	TRY
		GOSUB Update
		GOSUB Update
		GOSUB Render
	CATCH ex$
	FINALLY

	SHOWSCREEN
ENDSUB



SUB Update:
	MOUSESTATE MouseX, MouseY, ML, MR

	SELECT Gamestate
		CASE STATE_IS_GAME
			Map.Update()
			FOREACH Enemy IN Enemys[]
				Enemy.Update()
			NEXT
			FOREACH Shit IN Shits[]
				Shit.Update()
				IF Shit.Del THEN DELETE Shit
			NEXT
			FOREACH Spit IN Spits[]
				Spit.Update()
				IF Spit.Del THEN DELETE Spit
			NEXT
			FOREACH Explosion IN Explosions[]
				Explosion.Update()
				IF Explosion.Del THEN DELETE Explosion
			NEXT
			Player.Update()

	ENDSELECT
ENDSUB


SUB Render:
	LOCAL Width, Height
	GETSCREENSIZE Width, Height
//	LOCAL SprWidth, SprHeight
//	GETSPRITESIZE BGImage, SprWidth, SprHeight
//	STARTPOLY BGImage, 0
//	POLYVECTOR 0		,0		,0,0,RGB(255,255,255)
//	POLYVECTOR Width	,0		,SprWidth,0,RGB(255,255,255)
//	POLYVECTOR Width	,Height	,SprWidth,SprHeight,RGB(255,255,255)
//	POLYVECTOR 0		,Height	,0,SprHeight,RGB(255,255,255)
//	ENDPOLY

	SELECT Gamestate
		CASE STATE_IS_GAME
			FOREACH Shit IN Shits[]
				Shit.Render()
			NEXT

			Map.Render()

			FOREACH Spit IN Spits[]
				Spit.Render()
			NEXT

			FOREACH Enemy IN Enemys[]
				Enemy.Render()
			NEXT

			FOREACH Explosion IN Explosions[]
				Explosion.Render()
			NEXT

			Player.Render()

			IF Hardware$
				GameButton(42,Height - 42, "<")
				GameButton(Width - 42,Height - 42, ">")
				GameButton(42, Height - 125, "jump")
				GameButton(Width - 42, Height - 125, "jump")
			ENDIF
	ENDSELECT
ENDSUB


SUB Init:
	LOCAL Width, Height
	GETSCREENSIZE Width, Height
	SELECT Gamestate
		CASE STATE_IS_GAME
			Player.Init(100,100)
			Map.Init("map3.map")
	ENDSELECT

	DIM LastMousePosition[0]
ENDSUB


FUNCTION IsEnemy%:
	IF SelectTile = 8 OR SelectTile = 6 OR SelectTile = 9 OR SelectTile = 7
		RETURN TRUE
	ELSE
		RETURN FALSE
	ENDIF
ENDFUNCTION

GLOBAL Title$, Menu1$, Menu2$, Menu3$ = "", Action%

SUB MENU_LOOP:
	LOCAL x,y
	GETFONTSIZE x,y
	LOCAL w, h
	GETSCREENSIZE w, h
	LOCAL iw, ih
	GETSPRITESIZE MenuImage, iw, ih


	LOCAL hh = h-150

	Action% = 0

	MOUSESTATE MouseX, MouseY, ML, MR
	GOSUB Render
	//Render() //geht komischerweise
	STRETCHSPRITE MenuImage, w - LEN(Title$, TRUE), 40 - 32, -w - LEN(Title$, TRUE), ih
	PRINT Title$, 20,40-y/2

	IF Button(Menu1$, hh/3+100) THEN Action = 1
	IF Button(Menu2$, hh/3*2+100) THEN Action = 2
	IF Menu3$ <> "" THEN IF Button(Menu3$, hh+100) THEN Action = 3

	SELECT Action
		CASE 1
			Gamestate = STATE_IS_GAME
			POPLOOP
		CASE 3
			END
	ENDSELECT
	IF Action THEN GOSUB Init

	SHOWSCREEN
ENDSUB

FUNCTION Button%: Text$, Y
	LOCAL x,y
	GETFONTSIZE x,y
	LOCAL w, h
	GETSCREENSIZE w, h
	LOCAL iw, ih
	GETSPRITESIZE MenuImage, iw, ih

	IF BOXCOLL(0, Y - 32, w, ih, MouseX, MouseY, 1, 1)
		ALPHAMODE 0
		IF ML
			RETURN TRUE
		ENDIF
	ELSE
		ALPHAMODE -.75
	ENDIF
	STRETCHSPRITE MenuImage, 0, Y-32, w, ih
	ALPHAMODE 0

	PRINT Text$, 40, Y-y/2

	RETURN FALSE
ENDFUNCTION


FUNCTION GameButton%: X, Y, Text$
	IF UpdateGameButton(X, Y)
		ALPHAMODE .5
	ELSE
		ALPHAMODE -0.5
	ENDIF

	DRAWSPRITE ButtonImage, X - 32, Y - 32
	SELECT Text$
		CASE "<"
			DRAWSPRITE ArrowImage, X - 32, Y - 32
		CASE ">"
			ZOOMSPRITE ArrowImage, X - 32, Y - 32, -1, 1
		CASE "jump"
			DRAWSPRITE JumpImage, X- 32, Y -32
	ENDSELECT

	ALPHAMODE 0
ENDFUNCTION

FUNCTION UpdateGameButton: X, Y
	LOCAL MX, MY, ML, MR
	FOR i = 0 TO GETMOUSECOUNT()-1
		SETACTIVEMOUSE i
		MOUSESTATE MX, MY, ML, MR
		IF BOXCOLL(X-32, Y-32, 64, 64, MX, MY, 1, 1) AND ML
			SETACTIVEMOUSE 0
			RETURN TRUE
		ENDIF
	NEXT
	SETACTIVEMOUSE 0
	RETURN FALSE
ENDFUNCTION

//$$RESETFILE.\Enemy.gbas
// --------------------------------- //
// Project: JumpIt
// Start: Monday, September 26, 2011
// IDE Version: 10.118

CONSTANT IS_BIRD 	= 1
CONSTANT IS_PIG 	= 2
CONSTANT IS_HUMAN 	= 3
CONSTANT IS_LLAMA 	= 4

GLOBAL Enemys[] AS TEnemy


TYPE TEnemy
	Typ% //vogel = 1, schwein = 2, mensch = 3 oder Llama = 4
	X; Y
	VX; VY
	Width; Height
	Anim%
	Fall%
	EventCounter%


	FUNCTION Update:
		IF self.Fall
			self.VY = self.VY +.2

			INC self.Y, self.VY
		ELSE
			INC self.Anim
			SELECT self.Typ
				CASE IS_BIRD
					IF (Map.CollisionPoint(self.X + 2 + self.VX, self.Y+self.Height/2) OR Map.CollisionPoint(self.X - 2 + self.VX + self.Width, self.Y+self.Height/2)) OR self.X + self.VX < 0 OR self.X + self.VX > Map.Width*Tilesize
						self.VX = -self.VX
					ENDIF
					INC self.X, self.VX
					self.VY = QCOS(GETTIMERALL()/10)
					IF Map.Collision(self.X+4,self.Y + self.VY,self.Width-8,self.Height)
						self.VY = 0
					ENDIF

					INC self.EventCounter
					IF MOD(self.EventCounter, RND(500)) = 5
						LOCAL S AS TShit
						S.Init(self.X, self.Y)
					ENDIF

					INC self.Y, self.VY

					self.Anim = MOD(self.Anim, 15*2)
				CASE IS_PIG TO IS_LLAMA
					SELECT self.Typ
						CASE IS_LLAMA
							self.Anim = MOD(self.Anim, 15)
							INC self.EventCounter

							LOCAL Look
							IF self.VX < 0
								Look = 0
							ELSE
								Look = self.Width/2
							ENDIF

							IF MOD(self.EventCounter, 55) = 5 AND Map.RayCollision(self.X + Look, self.Y + 4, Player.X, Player.Y) = FALSE


								LOCAL S AS TSpit
								S.Init(self.X+Look, self.Y+4, self.VX*4, self.VY  - RND(2))
							ENDIF
						CASE IS_PIG
							self.Anim = MOD(self.Anim, 10)
					ENDSELECT

					IF (Map.CollisionPoint(self.X + self.VX, self.Y + self.Height + 1) = FALSE OR Map.CollisionPoint(self.X+self.Width+self.VX, self.Y + self.Height + 1) = FALSE) OR (Map.CollisionPoint(self.X + 2 + self.VX, self.Y+self.Height/2) OR Map.CollisionPoint(self.X - 2 + self.VX + self.Width, self.Y+self.Height/2)) OR self.X + self.VX < 0 OR self.X + self.VX > Map.Width*Tilesize
						self.VX = -self.VX
					ENDIF
					INC self.X, self.VX
			ENDSELECT
		ENDIF
	ENDFUNCTION

	FUNCTION Render:
		LOCAL Frame% = 0

		SELECT self.Typ
			CASE IS_BIRD
				LOCAL Dir%
				IF self.VX > 0
					Dir = 1
				ELSE
					Dir = 0
				ENDIF
				IF self.Anim > 10*2
					Frame = 2
				ELSEIF self.Anim > 5*2
					Frame = 1
				ELSE
					Frame = 0
				ENDIF

				TurnImage(BirdImage,Frame, Dir, self.X, self.Y, 6)
			CASE IS_PIG
				LOCAL Dir%
				IF self.VX < 0
					Dir = 0
				ELSE
					Dir = 1
				ENDIF

				IF self.Anim > 5
					Frame = 1
				ELSE
					Frame = 0
				ENDIF


				TurnImage(PigImage, Frame, Dir, self.X, self.Y, 4)
			CASE IS_HUMAN
				ROTOSPRITE HumanImage, self.X + Map.ScrollX, self.Y + Map.ScrollY, -MOD(self.X, 360)
			CASE IS_LLAMA
				LOCAL Dir%
				IF self.VX < 0
					Dir = 1
				ELSE
					Dir = 0
				ENDIF

				IF self.Anim > 10
					Frame = 2
				ELSEIF self.Anim > 5
					Frame = 1
				ELSE
					Frame = 0
				ENDIF


				TurnImage(LlamaImage, Frame, Dir, self.X, self.Y, 6)
		ENDSELECT
	ENDFUNCTION

	FUNCTION Init: Typ%, X, Y
		self.Typ 	= Typ
		self.X 		= X
		self.Y 		= Y
		self.Width 	= Tilesize
		self.Height = Tilesize

		SELECT self.Typ
			CASE IS_BIRD
				self.Height 	= Tilesize/2
				IF INTEGER(RND(2))
					self.VX 	= 1
				ELSE
					self.VX 	= -1
				ENDIF
			CASE IS_PIG
				IF INTEGER(RND(2))
					self.VX 	= 2
				ELSE
					self.VX		= -2
				ENDIF
			CASE IS_HUMAN
				self.Y 			= self.Y - Tilesize
				self.Height 	= Tilesize*2
				self.Width 		= Tilesize*2
				IF INTEGER(RND(2))
					self.VX 	= 1
				ELSE
					self.VX 	= -1
				ENDIF
			CASE IS_LLAMA
				self.Y = self.Y - Tilesize
				self.Height 	= Tilesize*2
				self.Width 		= Tilesize*2
				IF INTEGER(RND(2))
					self.VX 	= 1
				ELSE
					self.VX 	= -1
				ENDIF
		ENDSELECT

		DIMPUSH Enemys[], self
	ENDFUNCTION

	FUNCTION IsDestroyable:
		IF self.Typ = IS_HUMAN
			RETURN FALSE
		ELSE
			RETURN TRUE
		ENDIF
	ENDFUNCTION
ENDTYPE

//$$RESETFILE.\Explosion.gbas
// --------------------------------- //
// Project: JumpIt
// Start: Saturday, October 01, 2011
// IDE Version: 10.118


GLOBAL Explosions[] AS TExplosion

TYPE TExplosion
	X;Y
	Anim%
	Del%

	FUNCTION Update:
		INC self.Anim
		IF self.Anim> 20 THEN self.Del = TRUE
	ENDFUNCTION

	FUNCTION Render:
		LOCAL Frame%
		IF self.Anim>15
			Frame = 3
		ELSEIF self.Anim>10
			Frame = 2
		ELSEIF self.Anim>5
			Frame = 1
		ELSE
			Frame = 0
		ENDIF

		DRAWANIM ExplosionImage, Frame, self.X + Map.ScrollX, self.Y + Map.ScrollY
	ENDFUNCTION

	FUNCTION Init: X, Y
		self.X = X
		self.Y = Y

		DIMPUSH Explosions[], self
	ENDFUNCTION
ENDTYPE

//$$RESETFILE.\Map.gbas
// --------------------------------- //
// Project: JumpIt
// Start: Sunday, September 25, 2011
// IDE Version: 10.118

CONSTANT Tilesize = 32

//Spielkarte

TYPE TMap
	IsSnow%
	Datas%[]
	Width%; Height%
	ScrollX; ScrollY
	Tileset% //die frames gespeichert
	TilesetPath$
	SpikePosition; SpikeDir%
	SpawnX%; SpawnY%
	NextMap$ = ""
	LastPickX%; LastPickY%
	HasFBO%; IsRenderedFBO%; ScreenID%; SprID%

	FUNCTION InitEmpty: Width%, Height%, Tileset$
		self.IsSnow = FALSE
		self.Width = Width
		self.Height = Height

		self.ScrollX = 0
		self.ScrollY = 0

		DIM Spits[0]
		DIM Shits[0]
		DIM Enemys[0]
		Player.Init(100,100)

		self.Tileset = GENSPRITE()
		self.TilesetPath$ = Tileset$
		LOADANIM Tileset$, self.Tileset, 32, 32
		IF INSTR(Tileset$,"snowtileset") <> -1 THEN self.IsSnow = TRUE



		DIM self.Datas[self.Width][self.Height]

		self.HasFBO = PLATFORMINFO$("GLEX:glBindFramebufferEXT")
		IF self.HasFBO
			self.SprID = GENSPRITE()
			self.IsRenderedFBO = 0
			self.ScreenID = 0
			LOADSPRITE "", self.SprID
			CREATESCREEN self.ScreenID, self.SprID, self.Width*Tilesize, self.Height*Tilesize
		ENDIF
	ENDFUNCTION

	FUNCTION Save: File$
		LOCAL Chn% = GENFILE()
		IF DOESFILEEXIST(File$) THEN KILLFILE File$
		IF OPENFILE(Chn, File$, 0) = FALSE THEN END


		WRITELINE Chn, self.Width
		WRITELINE Chn, self.Height
		WRITELINE Chn, self.TilesetPath$
		WRITELINE Chn, self.NextMap$
		FOR y = 0 TO self.Height -1
			LOCAL Line$ = ""
			FOR x = 0 TO self.Width -1
				IF x > 0 THEN Line$ = Line$ + ","
				LOCAL PositionData% = self.Datas[x][y]
				FOREACH Enem IN Enemys[]
					IF INTEGER(Enem.X/Tilesize) = x AND INTEGER((Enem.Y + Enem.Height - 1)/Tilesize) = y
						SELECT Enem.Typ
							CASE IS_BIRD
								PositionData = 8
							CASE IS_PIG
								PositionData = 6
							CASE IS_LLAMA
								PositionData = 9
							CASE IS_HUMAN
								PositionData = 7
						ENDSELECT
						BREAK
					ENDIF
				NEXT

				Line$ = Line$ + PositionData
			NEXT
			WRITELINE Chn, Line$
		NEXT

		CLOSEFILE Chn
	ENDFUNCTION

	FUNCTION Init: Name$
		LOCAL Chn% = GENFILE()
		LOCAL Line$, Tileset$

		IF OPENFILE(Chn, Name$, 1) = FALSE THEN END

		READLINE Chn, Line$
		self.Width = INTEGER(Line$)

		READLINE Chn, Line$
		self.Height = INTEGER(Line$)

		READLINE Chn, Line$
		Tileset$ = Line$

		READLINE Chn, Line$
		self.NextMap$ = Line$

		self.InitEmpty(self.Width, self.Height, Tileset$)

		LOCAL x%, y%
		WHILE ENDOFFILE(Chn) = FALSE
			READLINE Chn, Line$
			LOCAL Tiles$[]

			SPLITSTR(Line$, Tiles$[], ",")


			x = 0
			FOREACH tile IN Tiles$[]
				self.Datas[x][y] = Convert(tile)
				SELECT self.Datas[x][y]
					CASE 4
						Player.X = x*Tilesize
						Player.Y = y*Tilesize
						self.SpawnX = Player.X
						self.SpawnY = Player.Y
						self.Datas[x][y] = 0
					CASE 6 TO 9
						LOCAL Typ
						SELECT self.Datas[x][y]
							CASE 6
								Typ = IS_PIG
							CASE 7
								Typ = IS_HUMAN
							CASE 8
								Typ = IS_BIRD
							CASE 9
								Typ = IS_LLAMA
						ENDSELECT
						LOCAL Enemy AS TEnemy
						Enemy.Init(Typ,x*Tilesize, y*Tilesize)
						self.Datas[x][y] = 0
				ENDSELECT
				INC x
			NEXT

			INC y
		WEND

		CLOSEFILE Chn
	ENDFUNCTION

	FUNCTION Update:
		IF self.SpikeDir
			DEC self.SpikePosition, 0.5
			IF self.SpikePosition <= 0
				self.SpikePosition = 0
				self.SpikeDir = FALSE
			ENDIF
		ELSE
			INC self.SpikePosition, 0.5
			IF self.SpikePosition >= Tilesize
				self.SpikeDir = TRUE
				self.SpikePosition = Tilesize
			ENDIF
		ENDIF
	ENDFUNCTION

	FUNCTION Render:
		LOCAL TmpScrollX, TmpScrollY
		TmpScrollX = self.ScrollX; TmpScrollY = self.ScrollY

		IF self.IsRenderedFBO = FALSE AND self.HasFBO
			USESCREEN self.ScreenID
			DRAWRECT 0,0,self.Width*Tilesize,self.Height*Tilesize,RGB(255,0,128)
			self.ScrollX = 0
			self.ScrollY = 0
		ENDIF

		IF self.HasFBO = FALSE OR self.IsRenderedFBO = FALSE
			LOCAL width, height
			GETSCREENSIZE width, height
			width = INTEGER(width/Tilesize)+1
			height = INTEGER(height/Tilesize)+1
			LOCAL sx = -INTEGER(self.ScrollX/Tilesize)-1
			LOCAL sy = -INTEGER(self.ScrollY/Tilesize)-1


			//alles aus die tiles rendern
			FOR x =sx TO sx + width
				FOR y = sy TO sy + height
					IF x >= 0 AND y >= 0 AND x < self.Width AND y < self.Height
						IF self.Datas[x][y] <> 1 THEN RenderTile(self.Datas[x][y], x, y, FALSE)
					ENDIF
				NEXT
			NEXT


			//tiles rendern
			STARTPOLY self.Tileset, 2
			FOR x =sx TO sx + width
				FOR y = sy TO sy + height
					IF x >= 0 AND y >= 0 AND x < self.Width AND y < self.Height
						IF self.Datas[x][y] = 1 THEN RenderTile(self.Datas[x][y], x, y, TRUE)
					ENDIF
				NEXT
			NEXT
			ENDPOLY

		ENDIF

		IF self.IsRenderedFBO = FALSE AND self.HasFBO
			USESCREEN -1
			self.IsRenderedFBO = TRUE
			self.ScrollX = TmpScrollX
			self.ScrollY = TmpScrollY
		ENDIF
		IF self.IsRenderedFBO
			DRAWSPRITE self.SprID, self.ScrollX, self.ScrollY
		ENDIF
	ENDFUNCTION

	FUNCTION RenderTile: Tile%, x, y, IsPoly%
		IF NOT(x>=0 AND y >=0 AND x < Map.Width AND y <Map.Height) THEN RETURN

		SELECT Tile
			CASE 1
				LOCAL Tile%
				IF (y = 0 OR IsCollisionTile(self.Datas[x][y-1])) AND (x = 0 OR IsCollisionTile(self.Datas[x-1][y]))
					IF (y = 0 OR IsCollisionTile(self.Datas[x][y-1])) AND (x = (self.Width-1) OR IsCollisionTile(self.Datas[x+1][y]))
						Tile = 1
					ELSE
						Tile = 2
					ENDIF
				ELSEIF (y = 0 OR IsCollisionTile(self.Datas[x][y-1])) AND (x = (self.Width-1) OR self.Datas[x+1][y] = 0)
					Tile = 3
				ELSEIF y = 0 OR IsCollisionTile(self.Datas[x][y-1])
					Tile = 1
				ELSE
					Tile = 0
				ENDIF

				IF IsPoly = FALSE
					DRAWANIM self.Tileset, Tile, x*Tilesize + self.ScrollX, y*Tilesize + self.ScrollY
				ELSE
					POLYVECTOR x*Tilesize + self.ScrollX			, y*Tilesize + self.ScrollY -1				, Tile*Tilesize			, 0 		, RGB(255,255,255)
					POLYVECTOR x*Tilesize + self.ScrollX + Tilesize	, y*Tilesize + self.ScrollY	-1				, (Tile+1)*Tilesize		, 0			, RGB(255,255,255)
					POLYVECTOR x*Tilesize + self.ScrollX			, y*Tilesize + self.ScrollY + Tilesize -1	, Tile*Tilesize			, Tilesize-1, RGB(255,255,255)
					POLYVECTOR x*Tilesize + self.ScrollX + Tilesize , y*Tilesize + self.ScrollY + Tilesize -1	, (Tile+1)*Tilesize		, Tilesize-1, RGB(255,255,255)

					POLYNEWSTRIP
				ENDIF
			CASE 2
				DRAWSPRITE LadderImage, x*Tilesize + self.ScrollX, y*Tilesize + self.ScrollY
			CASE 3
				DRAWSPRITE SpikeImage, x*Tilesize + self.ScrollX, y*Tilesize + self.ScrollY + self.SpikePosition
			CASE 4
				//DRAWRECT x*Tilesize + self.ScrollX, y*Tilesize + self.ScrollY, Tilesize, Tilesize, RGB(0,255,0)
			CASE 5
				DRAWSPRITE TrampolineImage, x*Tilesize + self.ScrollX, y*Tilesize + self.ScrollY + 16
			CASE 10
				DRAWSPRITE DoorImage, x*Tilesize + self.ScrollX, y*Tilesize + self.ScrollY
			CASE 11
				DRAWSPRITE DynamitImage, x*Tilesize + self.ScrollX, y*Tilesize + self.ScrollY
			CASE 12
				DRAWANIM TriggerImage, 0, x*Tilesize + self.ScrollX, y*Tilesize + self.ScrollY+Tilesize/2
			CASE 13
				DRAWANIM TriggerImage, 1, x*Tilesize + self.ScrollX, y*Tilesize + self.ScrollY+Tilesize/2
		ENDSELECT
	ENDFUNCTION

	//Gibt das tile an der gegebenen Stelle zurück
	FUNCTION PickTile:  X, Y
		IF X >= 0 AND Y >= 0 AND X < self.Width*Tilesize AND Y < self.Height*Tilesize
			//yay es ist in der map!
			X = INTEGER(X/Tilesize)
			Y = INTEGER(Y/Tilesize)
			self.LastPickX = X
			self.LastPickY = Y
			RETURN self.Datas[X][Y]
		ELSE
			RETURN 0
		ENDIF
	ENDFUNCTION

	//entfernt das tile an der position
	FUNCTION RemoveTile: X, Y
		IF X >= 0 AND Y>=0 AND X<Map.Width AND Y < Map.Height
			self.Datas[X][Y] = 0
			self.IsRenderedFBO = FALSE
		ENDIF
	ENDFUNCTION

	//Punktskollision
	FUNCTION CollisionPoint%: X, Y
		LOCAL TmpY = Y
		IF X >= 0 AND Y >= 0 AND X < self.Width*Tilesize AND Y < self.Height*Tilesize
			//yay es ist in der map!
			X = INTEGER(X/Tilesize)
			Y = INTEGER(Y/Tilesize)

			IF IsCollisionTile(self.Datas[X][Y]) = FALSE
				IF self.Datas[X][Y] = 5 OR self.Datas[X][Y] = 12 OR self.Datas[X][Y] = 13
					//halbteil!
					IF MOD(TmpY,32) > 16
						RETURN TRUE
					ELSE
						RETURN FALSE
					ENDIF
				ENDIF
				RETURN TRUE
			ELSE
				RETURN FALSE
			ENDIF
		ELSE
			RETURN FALSE
		ENDIF
	ENDFUNCTION

	//Linienkollision
	FUNCTION RayCollision: X1, Y1, X2, Y2
		LOCAL Length = SQR(X1*X1 + Y1*Y1 + X2*X2 + Y2*Y2)
		LOCAL DeltaX = (X1 - X2)/Length
		LOCAL DeltaY = (Y1 - Y2)/Length
		FOR i = 0 TO Length
			IF CollisionPoint(X1 - DeltaX*i, Y1 - DeltaY*i)
				RETURN TRUE
			ENDIF
		NEXT
		RETURN FALSE
	ENDFUNCTION

	//Rechteckskollision
	FUNCTION Collision%: X, Y, Width, Height
		FOR XX = X TO X + Width STEP 4
			FOR YY = Y TO Y + Height STEP 4
				IF CollisionPoint(XX, YY) THEN RETURN TRUE
			NEXT
		NEXT

		//eckpunkte!
		IF CollisionPoint(X,Y) OR CollisionPoint(X + Width, Y) OR CollisionPoint(X, Y + Height) OR CollisionPoint(X + Width, Y + Height)
			RETURN TRUE
		ELSE
			RETURN FALSE
		ENDIF
	ENDFUNCTION
ENDTYPE

FUNCTION IsCollisionTile%: Typ%
	IF Typ = 0 OR Typ = 2 OR Typ = 3 OR Typ = 10
		RETURN TRUE
	ELSE
		RETURN FALSE
	ENDIF
ENDFUNCTION

FUNCTION Convert%: Text$
	SELECT Text$
		CASE "A"
			RETURN 10
		CASE "B"
			RETURN 11
		CASE "C"
			RETURN 12
		DEFAULT
			RETURN INTEGER(Text$)
	ENDSELECT
ENDFUNCTION

//$$RESETFILE.\Player.gbas
// --------------------------------- //
// Project: JumpIt
// Start: Sunday, September 25, 2011
// IDE Version: 10.118

// Spieler
TYPE TPlayer
	X; Y
	VX; VY
	Width%; Height%
	Anim%
	// ...

	FUNCTION Init: X, Y, Width% = 16, Height% = 32
		self.X 		= X
		self.Y 		= Y
		self.VX 	= 0
		self.VY 	= 0

		self.Width 	= Width
		self.Height = Height
	ENDFUNCTION

	FUNCTION Update:
		LOCAL ScrWidth, ScrHeight
		GETSCREENSIZE ScrWidth, ScrHeight

		//schwerkraft
		INC self.VY, .5

		//bewegung
		IF KEY(203) OR UpdateGameButton(42,ScrHeight - 42) THEN DEC self.VX, 1//links
		IF KEY(205) OR UpdateGameButton(ScrWidth - 42,ScrHeight - 42) THEN INC self.VX, 1 //rechts
		IF KEY(57) OR (UpdateGameButton(42, ScrHeight - 125) OR UpdateGameButton(ScrWidth - 42, ScrHeight - 125))
			IF Map.PickTile(self.X+self.Width/2, self.Y) = 2 //leiter
				self.VY = 0
				DEC self.Y, 4

				WHILE Map.PickTile(self.X+self.Width/2, self.Y) <> 2
					INC self.Y, 1
				WEND

			ELSEIF (Map.CollisionPoint(self.X + 1, self.Y + self.Height + 1) OR Map.CollisionPoint(self.X + self.Width - 1, self.Y + self.Height + 1)) //springen
				self.VY = -8
			ENDIF
		ENDIF

		//nächste map laden?
		IF Map.PickTile(self.X+self.Width/2, self.Y+self.Height/2) = 10
			//yay nächste map!111
			IF Map.NextMap$ = ""
				END //TODO
			ELSE
				Map.Init(Map.NextMap$)
				THROW "Exit"
			ENDIF
		ENDIF

		//trägheit
		self.VX = self.VX * (.77+Map.IsSnow*.1)

		//grenze
		IF self.VY > Tilesize-1 THEN self.VY = Tilesize-1
		IF self.VY < -Tilesize-1 THEN self.VY = -Tilesize-1


		LOCAL OldX, OldY
		OldX = self.X
		OldY = self.Y

		//bewege und kollision
		INC self.X, self.VX
		IF Map.Collision(self.X+1, self.Y+1, self.Width-2, self.Height-2)
			self.X = OldX
		ENDIF

		INC self.Y, self.VY
		IF Map.Collision(self.X+1, self.Y+1, self.Width-2, self.Height-2)
			self.Y = OldY
			self.VY = 0
		ENDIF

		//animation
		IF ABS(self.VX)>.1
			INC self.Anim, 1
			self.Anim = MOD(self.Anim, 15)
		ELSE
			self.Anim = 13
		ENDIF

		//spikes
		IF Map.PickTile(self.X+4, self.Y - Map.SpikePosition  + Tilesize  - 1) = 3 OR Map.PickTile(self.X + self.Width-4, self.Y - Map.SpikePosition + Tilesize - 1) = 3
			self.Reset()
		ENDIF

		//trampolin
		IF Map.PickTile(self.X+2, self.Y + self.Height + self.VY - 16) = 5 OR Map.PickTile(self.X + self.Width-4, self.Y + self.Height + self.VY - 16) = 5 AND ABS(self.VY)>.25
			self.VY = -self.VY*1.1
		ENDIF

		//schalter
		IF Map.PickTile(self.X, self.Y + self.Height + self.VY - 16) = 12 OR Map.PickTile(self.X + self.Width-4, self.Y + self.Height + self.VY - 16) = 12
			//yay es ist in der map!
			Map.Datas[Map.LastPickX][Map.LastPickY] = 13
			Map.IsRenderedFBO = FALSE

			//suche das nächste dynamit
			LOCAL LastPosX, LastPosY, Dist = -1
			FOR x = 0 TO Map.Width - 1
				FOR y = 0 TO Map.Height - 1
					IF Map.Datas[x][y] = 11
						LOCAL TmpDist = SQR((x-Map.LastPickX)*(x-Map.LastPickX) + (y-Map.LastPickY)*(y-Map.LastPickY))
						IF Dist = -1 OR TmpDist < Dist
							Dist = TmpDist
							LastPosX = x
							LastPosY = y
						ENDIF
					ENDIF
				NEXT
			NEXT

			IF Dist <> -1
				//druckwelle
				LOCAL X1, Y1, X2,Y2
				//DEBUG LastPosX+" "+LastPosY+"\n"
				Y1 = LastPosY*Tilesize + 16; Y2 = self.Y + self.Height/2
				X1 = LastPosX*Tilesize + 16; X2 = self.X + self.Width/2
				LOCAL Angle = -MOD(ATAN((Y1 - Y2), (X1 - X2)) + 180, 360)
				LOCAL Dist = SQR((X1 - X2)*(X1 - X2) + (Y1 - Y2)*(Y1 - Y2))
				//DEBUG Dist
				IF Dist < 512
					LOCAL Strength = 256/(Dist+1)*16
					INC self.VX, QCOS(Angle)*Strength
					INC self.VY, QSIN(Angle)*Strength
				ENDIF

				//explosion und so
				FOR X = -1 TO 1
					FOR Y = -1 TO 1
						Map.RemoveTile(LastPosX+X, LastPosY+Y)
						FOR XX = -0.5 TO 0.5 STEP 0.5
							FOR YY = -0.5 TO 0.5 STEP 0.5
								IF (INTEGER(RND(2))>1)
									LOCAL Exp AS TExplosion
									Exp.Init((LastPosX+X+XX)*Tilesize, (LastPosY+Y+YY)*Tilesize)
								ENDIF
							NEXT
						NEXT
					NEXT
				NEXT

				//gegner aua machen
				FOREACH Enemy IN Enemys[]
					IF SQR((Enemy.X - LastPosX*Tilesize)*(Enemy.X - LastPosX*Tilesize) + (Enemy.Y - LastPosY*Tilesize)) < Tilesize
						Enemy.Fall = TRUE
					ENDIF
				NEXT
			ENDIF
		ENDIF


		//gegner kollision
		FOREACH Enemy IN Enemys[]
			IF Enemy.Fall = FALSE
				IF BOXCOLL(self.X+2,self.Y+2,self.Width-4,self.Height+4,Enemy.X+4,Enemy.Y-8,Enemy.Width-8,16) AND Enemy.IsDestroyable() AND self.VY<>0
					Enemy.Fall = TRUE
				ELSEIF BOXCOLL(self.X+2,self.Y+2,self.Width-4,self.Height-4,Enemy.X+2,Enemy.Y+2,Enemy.Width-4,Enemy.Height-4)
					self.Reset()
					BREAK
				ENDIF
			ENDIF
		NEXT

		//exkrementkollision
		FOREACH S IN Shits[]
			IF BOXCOLL(self.X, self.Y, self.Width, self.Height, S.X, S.Y, 16, 16) AND S.VY <> 0
				self.Reset()
				DELETE S
			ENDIF
		NEXT

		//spuckkollision
		FOREACH S IN Spits[]
			IF BOXCOLL(self.X, self.Y, self.Width, self.Height, S.X, S.Y, 8, 8) AND S.VY <> 0
				self.Reset()
				DELETE S
			ENDIF
		NEXT


		//ist der spieler unter die Map gefallen?
		IF (self.Y - self.Height*2) > Map.Height*Tilesize
			self.Reset()
		ENDIF

		//scrolling
		Map.ScrollX = -self.X + ScrWidth/2 + self.Width/2
		Map.ScrollY = -self.Y + ScrHeight/2 + self.Height/2
	ENDFUNCTION

	FUNCTION Render:
		LOCAL CurAnim%
		IF self.Anim > 10
			CurAnim = 0
		ELSEIF self.Anim > 5
			CurAnim = 1
		ELSE
			CurAnim = 2
		ENDIF
		LOCAL Dir%

		IF self.VX < 0
			Dir = 1
		ELSE
			Dir = 0
		ENDIF


		TurnImage(PlayerImage, CurAnim, Dir, self.X + 1, self.Y, 6)
	ENDFUNCTION

	FUNCTION Reset:
		self.X = Map.SpawnX
		self.Y = Map.SpawnY
		self.VX = 0
		self.VY = 0
	ENDFUNCTION
ENDTYPE


FUNCTION TurnImage: Img%, Frame%, Dir%,X,Y, MaxFrame%
	IF Dir
		Frame = (MaxFrame - 1) - Frame
	ENDIF

	DRAWANIM Img,Frame, X + Map.ScrollX, Y + Map.ScrollY
ENDFUNCTION

//$$RESETFILE.\qmath.gbas
// --------------------------------- //
// Project: qmath - quick math approximations
// Start: Thursday, March 15, 2007
// IDE Version: 4.126



// Qedo http://www.glbasic.com/forum/index.php?topic=6446
FUNCTION QSIN: x
	?IFDEF HTML5
	//does not work well..
	RETURN SIN(x)
	?ELSE
    WHILE x>360.0;  DEC x, 360.0; WEND
    WHILE x<0;      INC x, 360.0; WEND

    IF x>180.0 THEN x = 180.0-x

	IF x>0
		x = (0.022221532036391804173392430864397 - 0.00012345295575773224540773572702443 * x) * x
		x = 0.225*(x*x-x)+x
	ELSE
		x = (0.022221532036391804173392430864397 + 0.00012345295575773224540773572702443 * x) * x
		x = 0.225*(-x*x-x)+x
	ENDIF
	RETURN x
	?ENDIF
ENDFUNCTION



FUNCTION QCOS: x
	?IFDEF HTML5
	RETURN COS(x)
	?ELSE
	RETURN QSIN(x+90)
	?ENDIF
ENDFUNCTION


FUNCTION QSQR: y
	RETURN SQR(y)
ENDFUNCTION





//$$RESETFILE.\Shit.gbas
// --------------------------------- //
// Project: JumpIt
// Start: Tuesday, September 27, 2011
// IDE Version: 10.118

GLOBAL Shits[] AS TShit

TYPE TShit
	Del%
	X;Y
	VY
	Age%
	Al

	FUNCTION Render:
		DRAWSPRITE ShitImage, self.X + Map.ScrollX, self.Y + Map.ScrollY
	ENDFUNCTION

	FUNCTION Update:
		IF self.Age > 149
			self.Del = TRUE
		ENDIF

		IF self.Y > Map.Height*Tilesize + Tilesize*20 THEN self.Del = TRUE


		IF Map.CollisionPoint(self.X+8,self.Y + self.VY + 16)
			WHILE Map.CollisionPoint(self.X+8,self.Y + 16) = FALSE
				INC self.Y
			WEND
			self.VY = 0
			INC self.Age
		ELSE
			INC self.VY, 1
		ENDIF
		self.VY = MIN(self.VY, 8)


		INC self.Y, self.VY
	ENDFUNCTION

	FUNCTION Init: X, Y
		self.X 	= X
		self.Y 	= Y
		self.VY = 1

		DIMPUSH Shits[], self
	ENDFUNCTION
ENDTYPE

//$$RESETFILE.\Spit.gbas
// --------------------------------- //
// Project: JumpIt
// Start: Tuesday, September 27, 2011
// IDE Version: 10.118
GLOBAL Spits[] AS TSpit

TYPE TSpit
	X;Y
	VX;VY
	Age%; Al
	Del%


	FUNCTION Update:
		self.VX = self.VX * .99
		INC self.VY, .1
		INC self.Age

		IF self.Age > 149
			self.Del = TRUE
		ENDIF


		LOCAL OldX, OldY
		OldX = self.X; OldY = self.Y

		INC self.X, self.VX
		IF Map.Collision(self.X, self.Y, 8,8)
			self.VX =  -self.VX
			self.X = OldX
		ENDIF
		INC self.Y, self.VY
		IF Map.Collision(self.X, self.Y, 8,8)
			self.VY =  -self.VY
			self.Y = OldY
		ENDIF
	ENDFUNCTION

	FUNCTION Render:
		DRAWSPRITE SpitImage, self.X+Map.ScrollX, self.Y+Map.ScrollY
	ENDFUNCTION

	FUNCTION Init: X, Y, DirX, DirY
		self.X 	= X
		self.Y	= Y
		self.VX = DirX
		self.VY = DirY

		DIMPUSH Spits[], self
	ENDFUNCTION
ENDTYPE

