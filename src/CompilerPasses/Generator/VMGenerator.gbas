// --------------------------------- //
// Project: 123basic
// Start: Sunday, June 30, 2013
// IDE Version: 10.283


?IFDEF VMCOMPILER


// ?DEFINE DEBUGVM

CONSTANT STACKENTRY_INT% 		= 1
CONSTANT STACKENTRY_FLOAT% 		= 2
CONSTANT STACKENTRY_STR% 		= 3
CONSTANT STACKENTRY_INTARRAY% 	= 4
CONSTANT STACKENTRY_FLOATARRAY% = 5
CONSTANT STACKENTRY_STRARRAY% 	= 6
CONSTANT STACKENTRY_VARI		= 7
CONSTANT STACKENTRY_VARIARR		= 8

CONSTANT EXECUTION_NORMAL		= 0
CONSTANT EXECUTION_BREAK		= 1
CONSTANT EXECUTION_CONTINUE		= 2
CONSTANT EXECUTION_RETURN		= 3


TYPE TStackEntry
	typ% = 0

	intVal%
	floatVal
	strVal$
	
	dims%[] // dimension information
	pos% // position information
	intArray%[]
	floatArray#[]
	strArray$[]

	vari%

	FUNCTION GetContent$:
		RETURN "Typ: "  + self.typ + " IntVal "+self.intVal+" FloatVal "+self.floatVal+" StringVal "+self.strVal$+" Len IntArray "+LEN(self.intArray[])+" Len FloatArray "+LEN(self.floatArray[])+" Len StringArray "+LEN(self.strArray$[])+" Variable "+self.vari+" Pos "+self.pos
	ENDFUNCTION

	FUNCTION GetFloat#: exec AS Executor
		SELECT self.typ
			CASE STACKENTRY_INT
				RETURN self.intVal
			CASE STACKENTRY_FLOAT
				RETURN self.floatVal
			CASE STACKENTRY_STR
				RETURN self.strVal$
			CASE STACKENTRY_INTARRAY
				RETURN self.intArray[self.pos]
			CASE STACKENTRY_FLOATARRAY
				RETURN self.floatArray[self.pos]
			CASE STACKENTRY_STRARRAY
				RETURN self.strArray$[self.pos]
			CASE STACKENTRY_VARI
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				RETURN S.Value.GetFloat(exec)
			CASE STACKENTRY_VARIARR
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				S.Value.pos = self.pos
				RETURN S.Value.GetFloat(exec)
			DEFAULT
				THROW "GetFloat: Unknown Typ "+self.typ
		ENDSELECT
	ENDFUNCTION

	FUNCTION GetStr$: exec AS Executor
		SELECT self.typ
			CASE STACKENTRY_INT
				RETURN self.intVal
			CASE STACKENTRY_FLOAT
				RETURN self.floatVal
			CASE STACKENTRY_STR
				RETURN self.strVal$
			CASE STACKENTRY_INTARRAY
				RETURN self.intArray[self.pos]
			CASE STACKENTRY_FLOATARRAY
				RETURN self.floatArray[self.pos]
			CASE STACKENTRY_STRARRAY
				RETURN self.strArray$[self.pos]
			CASE STACKENTRY_VARI
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				RETURN S.Value.GetStr$(exec)
			CASE STACKENTRY_VARIARR
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				S.Value.pos = self.pos
				RETURN S.Value.GetStr$(exec)
			DEFAULT
				THROW "GetStr: Unknown Typ "+self.typ
		ENDSELECT
	ENDFUNCTION

	FUNCTION GetInt%: exec AS Executor
		SELECT self.typ
			CASE STACKENTRY_INT
				RETURN self.intVal
			CASE STACKENTRY_FLOAT
				RETURN self.floatVal
			CASE STACKENTRY_STR
				RETURN self.strVal$
			CASE STACKENTRY_INTARRAY
				RETURN self.intArray[self.pos]
			CASE STACKENTRY_FLOATARRAY
				RETURN self.floatArray[self.pos]
			CASE STACKENTRY_STRARRAY
				RETURN self.strArray$[self.pos]
			CASE STACKENTRY_VARI
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				RETURN S.Value.GetInt(exec)
			CASE STACKENTRY_VARIARR
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				S.Value.pos = self.pos
				RETURN S.Value.GetInt(exec)
			DEFAULT
				THROW "GetInt: Unknown Typ "+self.typ
		ENDSELECT
	ENDFUNCTION

	FUNCTION GetVar%: exec AS Executor
		SELECT self.typ
			CASE STACKENTRY_VARI
				RETURN self.vari
			CASE STACKENTRY_VARIARR
				RETURN self.vari
			DEFAULT
				THROW "GetVar: Unknown Typ: "+self.typ
		ENDSELECT
	ENDFUNCTION
	
	FUNCTION SetInt: val%, exec AS Executor
		SELECT self.typ
			CASE STACKENTRY_VARI
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				S.Value.SetInt(val, exec)
			CASE STACKENTRY_VARIARR
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				S.Value.intArray[self.pos] = val
			DEFAULT
				self.typ = STACKENTRY_INT
				self.intVal = val
		ENDSELECT
	ENDFUNCTION
	
	FUNCTION SetFloat: val, exec AS Executor
		SELECT self.typ
			CASE STACKENTRY_VARI
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				S.Value.SetFloat(val, exec)
			CASE STACKENTRY_VARIARR
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				S.Value.floatArray[self.pos] = val
			DEFAULT
				self.typ = STACKENTRY_FLOAT
				self.floatVal = val
		ENDSELECT
	ENDFUNCTION
	
	FUNCTION SetStr: val$, exec AS Executor
		SELECT self.typ
			CASE STACKENTRY_VARI
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				S.Value.SetStr(val$, exec)
			CASE STACKENTRY_VARIARR
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				S.Value.strArray$[self.pos] = val$
			DEFAULT
				self.typ = STACKENTRY_STR
				self.strVal$ = val$
		ENDSELECT
	ENDFUNCTION
	
	FUNCTION SetArr: SE AS TStackEntry, pos%, exec AS Executor
		SELECT self.typ
			CASE STACKENTRY_FLOATARRAY
				self.floatArray[pos] = SE.GetFloat(exec)
			CASE STACKENTRY_INTARRAY
				self.intArray[pos] = SE.GetInt(exec)
			CASE STACKENTRY_STRARRAY
				self.strArray$[pos] = SE.GetStr$(exec)
			DEFAULT
				THROW "Cannot set non array"
		ENDSELECT
	ENDFUNCTION
	
	FUNCTION SetVar: val%, exec AS Executor
		Error("Unimplemented SetVar")
	ENDFUNCTION
	
	FUNCTION SetStackEntry: SE AS TStackEntry, exec AS Executor
		SELECT self.typ
			CASE STACKENTRY_INT
				self.SetInt(SE.GetInt(exec), exec)
			CASE STACKENTRY_FLOAT
				self.SetFloat(SE.GetFloat(exec), exec)
			CASE STACKENTRY_STR
				self.SetStr(SE.GetStr$(exec), exec)
			CASE STACKENTRY_INTARRAY
				self.intArray[] = SE.intArray[]
				self.dims[] = SE.dims[]
			CASE STACKENTRY_FLOATARRAY
				self.floatArray[] = SE.floatArray[]
				self.dims[] = SE.dims[]
			CASE STACKENTRY_STRARRAY
				self.strArray$[] = SE.strArray$[]
				self.dims[] = SE.dims[]
			CASE STACKENTRY_VARI
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				IF S.Value.IsStackEntryArray() AND SE.typ = STACKENTRY_VARI AND exec.comp.Varis[SE.vari].Value.IsStackEntryArray()
					S.Value = exec.comp.Varis[SE.vari].Value // copy array
				ELSE
					S.Value.SetStackEntry(SE, exec)
				ENDIF
			CASE STACKENTRY_VARIARR
				ALIAS S AS exec.comp.Varis[self.vari]
				PrepareVari(S)
				S.Value.SetArr(SE, self.pos, exec)
			DEFAULT
				THROW "SetStackEntry: Unknown Typ "+self.typ
		ENDSELECT
	ENDFUNCTION
	
	FUNCTION IsStackEntryArray%:
		IF self.typ = STACKENTRY_FLOATARRAY OR self.typ = STACKENTRY_INTARRAY OR self.typ = STACKENTRY_STRARRAY
			RETURN TRUE
		ELSE
			RETURN FALSE
		ENDIF
	ENDFUNCTION
ENDTYPE

PROTOTYPE ScriptFunc: Exec AS Executor

GLOBAL Funcs[] AS ScriptFunc
GLOBAL FuncMap AS HashMap

FUNCTION RegisterFunc: Name$, Func AS ScriptFunc
	DIMPUSH Funcs[], Func
	FuncMap.Put(Name$, LEN(Funcs[])-1)
ENDFUNCTION


TYPE Executor
	Stack[] AS TStackEntry

	comp AS TCompiler

	FUNCTION Execute:
		TRY
			self.ExecuteExpr(comp.MainScope)
		CATCH ex$
			STDOUT "Error "+ex$
		FINALLY
	ENDFUNCTION

	FUNCTION PopFloat:
		IF LEN(self.Stack[]) = 0 THEN Error("Stack is empty, cannot POP.")
		ALIAS S AS self.Stack[-1]
		LOCAL v = S.GetFloat(self)
		DIMDEL self.Stack[],-1
		RETURN v
	ENDFUNCTION


	FUNCTION PopInt%:
		IF LEN(self.Stack[]) = 0 THEN Error("Stack is empty, cannot POP.")
		ALIAS S AS self.Stack[-1]
		LOCAL v% = S.GetInt(self)
		DIMDEL self.Stack[],-1
		RETURN v
	ENDFUNCTION


	FUNCTION PopStr$:
		IF LEN(self.Stack[]) = 0 THEN Error("Stack is empty, cannot POP.")
		ALIAS S AS self.Stack[-1]
		LOCAL v$ = S.GetStr$(self)
		DIMDEL self.Stack[],-1
		RETURN v$
	ENDFUNCTION

	FUNCTION PopVar%:
		IF LEN(self.Stack[]) = 0 THEN Error("Stack is empty, cannot POP.")
		ALIAS S AS self.Stack[-1]
		LOCAL v = S.GetVar(self)
		DIMDEL self.Stack[],-1
		RETURN v
	ENDFUNCTION
	
	FUNCTION PushFloat: v
		LOCAL e AS TStackEntry
		e.typ = STACKENTRY_FLOAT
		e.floatVal = v
		DIMPUSH self.Stack[], e
	ENDFUNCTION

	FUNCTION PushInt: v%
		LOCAL e AS TStackEntry
		e.typ = STACKENTRY_INT
		e.intVal = v
		DIMPUSH self.Stack[], e
	ENDFUNCTION

	FUNCTION PushStr: v$
		LOCAL e AS TStackEntry
		e.typ = STACKENTRY_STR
		e.strVal$ = v$
		DIMPUSH self.Stack[], e
	ENDFUNCTION

	FUNCTION PushVari: vari%
		LOCAL e AS TStackEntry
		e.typ = STACKENTRY_VARI
		e.vari = vari
		DIMPUSH self.Stack[], e
	ENDFUNCTION
	
	FUNCTION PushVariArr: vari%, pos%
		LOCAL e AS TStackEntry
		e.typ = STACKENTRY_VARIARR
		e.vari = vari
		e.pos = pos
		e.dims = self.comp.Varis[vari].Value.dims[]
		
		DIMPUSH self.Stack[], e
	ENDFUNCTION

	FUNCTION Push: e AS TStackEntry
		DIMPUSH self.Stack[], e
	ENDFUNCTION

	FUNCTION Pop:
		IF LEN(self.Stack[]) = 0 THEN Error("Stack is empty, cannot POP.")
		DIMDEL self.Stack[], -1
	ENDFUNCTION

	//! Internal Function that executes a scope
	FUNCTION ExecuteExpr: exprId%
		ALIAS expr AS Exprs[exprId]
		IF expr.Typ = EXPR_IS_EMPTY THEN RETURN // useless

		?IFDEF DEBUGVM
		ALIAS tok AS self.comp.Tokens[expr.tokID]
		STDOUT "\tExecute OpCode "+GetExpressionName$(expr.Typ)+" Stacksize " + LEN(self.Stack[]) + " of file " + tok.Path$ + " in line "+ tok.Line +"\n"
		?ENDIF
		SELECT expr.Typ
			CASE EXPR_IS_SCOPE
				FOREACH e IN expr.Exprs[]
					LOCAL l% = LEN(self.Stack[])
					LOCAL result% = self.ExecuteExpr(e)
					
					ALIAS execExpr AS Exprs[e]
					IF execExpr.Typ = EXPR_IS_FUNCCALL AND execExpr.datatype.Name$ <> "void"
						// remove "value" from stack
						self.Pop()
					ENDIF
					
					IF result
						RETURN result
					ENDIF
					
					IF l <> LEN(self.Stack[])
						Error("Inconsistent Stack")
					ENDIF
				NEXT
			CASE EXPR_IS_OPERATOR
				// op1
				self.ExecuteExpr(expr.Left)
				
				// op2
				self.ExecuteExpr(expr.Right)
				
				LOCAL Sym$ = Operators[expr.Op].Sym$
				LOCAL HasToBeInt = FALSE
				SELECT Sym$
					CASE "="
						LOCAL v2 = self.PopFloat()
						LOCAL v1 = self.PopFloat()
						LOCAL r%
						IF v1 = v2
							r = TRUE
						ELSE
							r = FALSE
						ENDIF
						self.PushInt(r)
					CASE "<>"
						LOCAL v2 = self.PopFloat()
						LOCAL v1 = self.PopFloat()
						LOCAL r%
						IF v1 <> v2
							r = TRUE
						ELSE
							r = FALSE
						ENDIF
						self.PushInt(r)
					CASE "OR"
						LOCAL v2 = self.PopFloat()
						LOCAL v1 = self.PopFloat()
						LOCAL r%
						IF v1 OR v2
							r = TRUE
						ELSE
							r = FALSE
						ENDIF
						self.PushInt(r)
					CASE "AND"
						LOCAL v2 = self.PopFloat()
						LOCAL v1 = self.PopFloat()
						LOCAL r%
						IF v1 AND v2
							r = TRUE
						ELSE
							r = FALSE
						ENDIF
						self.PushInt(r)
					CASE "<"
						LOCAL v2 = self.PopFloat()
						LOCAL v1 = self.PopFloat()
						LOCAL r%
						IF v1 < v2
							r = TRUE
						ELSE
							r = FALSE
						ENDIF
						self.PushInt(r)
					CASE ">"
						LOCAL v2 = self.PopFloat()
						LOCAL v1 = self.PopFloat()
						LOCAL r%
						IF v1 > v2
							r = TRUE
						ELSE
							r = FALSE
						ENDIF
						self.PushInt(r)
					CASE ">="
						LOCAL v2 = self.PopFloat()
						LOCAL v1 = self.PopFloat()
						LOCAL r%
						IF v1 >= v2
							r = TRUE
						ELSE
							r = FALSE
						ENDIF
						self.PushInt(r)
					CASE "<="
						LOCAL v2 = self.PopFloat()
						LOCAL v1 = self.PopFloat()
						LOCAL r%
						IF v1 <= v2
							r = TRUE
						ELSE
							r = FALSE
						ENDIF
						self.PushInt(r)
					CASE "+"
						SELECT expr.datatype.Name$
							CASE "string"
								LOCAL v2$ = self.PopStr$()
								LOCAL v1$ = self.PopStr$()
								self.PushStr(v1$ + v2$)
							CASE "float"
								LOCAL v2 = self.PopFloat()
								LOCAL v1 = self.PopFloat()
								self.PushFloat(v1 + v2)
							CASE "int"
								LOCAL v2% = self.PopInt()
								LOCAL v1% = self.PopInt()
								self.PushInt(INTEGER(v1 + v2))
						ENDSELECT
					CASE "-"
						SELECT expr.datatype.Name$
							CASE "float"
								LOCAL v2 = self.PopFloat()
								LOCAL v1 = self.PopFloat()
								self.PushFloat(v1 - v2)
							CASE "int"
								LOCAL v2% = self.PopInt()
								LOCAL v1% = self.PopInt()
								self.PushInt(INTEGER(v1 - v2))
						ENDSELECT
					CASE "*"
						SELECT expr.datatype.Name$
							CASE "float"
								LOCAL v2 = self.PopFloat()
								LOCAL v1 = self.PopFloat()
								self.PushFloat(v1 * v2)
							CASE "int"
								LOCAL v2% = self.PopInt()
								LOCAL v1% = self.PopInt()
								self.PushInt(INTEGER(v1 * v2))
						ENDSELECT
					CASE "/"
						// always float
						LOCAL v2 = self.PopFloat()
						LOCAL v1 = self.PopFloat()
						self.PushFloat(v1 / v2)
					CASE "^"
						SELECT expr.datatype.Name$
							CASE "float"
								LOCAL v2 = self.PopFloat()
								LOCAL v1 = self.PopFloat()
								self.PushFloat(POW(v1, v2))
							CASE "int"
								LOCAL v2% = self.PopInt()
								LOCAL v1% = self.PopInt()
								self.PushInt(INTEGER(POW(v1, v2)))
						ENDSELECT
				ENDSELECT
			CASE EXPR_IS_INT
				self.PushInt(expr.intval)
			CASE EXPR_IS_FLOAT
				self.PushFloat(expr.floatval)
			CASE EXPR_IS_STR
				self.PushStr(MID$(expr.strval$,1,LEN(expr.strval$)-2))
			CASE EXPR_IS_FUNCCALL
				ALIAS Func AS self.comp.Funcs[expr.func]
				
				IF Func.Native
					// push parameters
					FOREACH P IN expr.Params[]
						self.ExecuteExpr(P)
					NEXT

					IF FuncMap.DoesKeyExist(Func.Name$)
						LOCAL p AS ScriptFunc
						LOCAL Value%
						FuncMap.GetValue(Func.Name$, Value%)
						p = Funcs[Value]
						p(self)
					ELSE
						Error("Missing native function"+Func.Name$)
					ENDIF
				ELSE
					// save values of variables (in order to allow recursion properly)
					ALIAS Scp AS Exprs[Func.Scp]
					LOCAL saveVaris[] AS IdentifierVari
					FOREACH V IN Scp.Varis[]
						DIMPUSH saveVaris[], self.comp.Varis[V]
					NEXT
					
					// set parameter values
					FOR i = 0 TO LEN(Func.CopyParams[]) - 1
						self.ExecuteExpr(expr.Params[i])
						ALIAS P AS self.comp.Varis[Func.CopyParams[i]]
						P.Value = self.Stack[-1]
						self.Pop()
					NEXT
					
					self.ExecuteExpr(Func.Scp)
					
					// restore values
					LOCAL i% = 0
					FOREACH V IN Scp.Varis[]
						self.comp.Varis[V] = saveVaris[i]
						INC i
					NEXT
				ENDIF
			CASE EXPR_IS_PROTOCALL
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_VARI
				ALIAS vari AS self.comp.Varis[expr.vari]
				PrepareVari(vari)
				self.PushVari(vari.ID)
				
				?IFDEF DEBUGVM
				STDOUT "Push Vari "+vari.ID+" With Content: "+vari.Value.GetContent$()+"\n"
				?ENDIF
			CASE EXPR_IS_ARRAY
				self.ExecuteExpr(expr.array)
				
				
				IF LEN(expr.dims[]) > 0
					LOCAL vari% = self.PopVar()
					ALIAS array AS self.comp.Varis[vari]
					PrepareVari(array)
					IF LEN(array.Value.dims[]) <> LEN(expr.dims[]) THEN Error("Wrong dimension count "+LEN(array.Value.dims[]) + " and " + LEN(expr.dims[]))
					
					LOCAL pos% = 0
					LOCAL mul% = 1
					FOR i = 0 TO LEN(array.Value.dims[]) - 1
						self.ExecuteExpr(expr.dims[i])
						
						LOCAL currentPos% = self.PopInt()
						IF currentPos < 0 THEN currentPos = array.Value.dims[i] + currentPos
						
						IF currentPos < 0 OR currentPos >= array.Value.dims[i]
							Error("Array index out of bounds "+currentPos+" "+array.Value.dims[i])
						ENDIF
						
						INC pos, currentPos * mul
						mul = mul * array.Value.dims[i]
					NEXT
					
					self.PushVariArr(vari, pos)
				ENDIF
			CASE EXPR_IS_ASSIGN
				self.ExecuteExpr(expr.vari)
				self.ExecuteExpr(expr.Right)
				
				LOCAL se AS TStackEntry = self.Stack[-1]
				self.Pop()
				ALIAS target AS self.Stack[-1]
				target.SetStackEntry(se, self)
				
				self.Pop()
			CASE EXPR_IS_DIM
				ALIAS array AS self.comp.Varis[GetVariable(expr.array)]
				PrepareVari(array)
				
				REDIM array.Value.dims[0]
				LOCAL size% = 1

				FOR i = 0 TO LEN(expr.dims[]) - 1
					self.ExecuteExpr(expr.dims[i])
					LOCAL curSize% = self.PopInt()
					size = size * curSize
					DIMPUSH array.Value.dims[], curSize
				NEXT
				
				SELECT array.datatype.Name$
					CASE "int"
						DIM array.Value.intArray[size]
					CASE "float"
						DIM array.Value.floatArray[size]
					CASE "string"
						DIM array.Value.strArray$[size]
					DEFAULT
						Error("Unimplemented Datatype")
				ENDSELECT
			CASE EXPR_IS_REDIM
				ALIAS array AS self.comp.Varis[GetVariable(expr.array)]
				PrepareVari(array)
				
				REDIM array.Value.dims[0]
				LOCAL size% = 1

				FOR i = 0 TO LEN(expr.dims[]) - 1
					self.ExecuteExpr(expr.dims[i])
					LOCAL curSize% = self.PopInt()
					size = size * curSize
					DIMPUSH array.Value.dims[], curSize
				NEXT
				
				SELECT array.datatype.Name$
					CASE "int"
						REDIM array.Value.intArray[size]
					CASE "float"
						REDIM array.Value.floatArray[size]
					CASE "string"
						REDIM array.Value.strArray$[size]
					DEFAULT
						Error("Unimplemented Datatype")
				ENDSELECT
			CASE EXPR_IS_CAST2INT
				self.ExecuteExpr(expr.expr)
				self.PushInt(self.PopInt())
				
				?IFDEF DEBUGVM
				ALIAS S AS self.Stack[-1]
				STDOUT "Cast2Int "+S.GetContent$()+"\n"
				?ENDIF
			CASE EXPR_IS_CAST2FLOAT
				self.ExecuteExpr(expr.expr)
				self.PushFloat(self.PopFloat())
				
				?IFDEF DEBUGVM
				ALIAS S AS self.Stack[-1]
				STDOUT "Cast2Float "+S.GetContent$()+"\n"
				?ENDIF
			CASE EXPR_IS_CAST2STRING
				self.ExecuteExpr(expr.expr)
				
				?IFDEF DEBUGVM
				ALIAS S AS self.Stack[-1]
				STDOUT "Cast2String "+S.GetContent$()+"\n"
				?ENDIF
				
				self.PushStr(self.PopStr$())
			CASE EXPR_IS_ACCESS
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_RETURN
				IF expr.expr <> -1
					self.ExecuteExpr(expr.expr)
				ENDIF
				RETURN EXECUTION_RETURN
			CASE EXPR_IS_FUNCDATA
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_IF
				LOCAL success% = FALSE
				FOR i = 0 TO LEN(expr.Conditions[]) - 1
					self.ExecuteExpr(expr.Conditions[i])
					IF self.PopInt()
						success = TRUE
						LOCAL result% = self.ExecuteExpr(expr.Scopes[i])
						IF result THEN RETURN result
						
						BREAK
					ENDIF
				NEXT

				IF NOT success AND expr.elseScope <> -1
					self.ExecuteExpr(expr.elseScope)
				ENDIF
			CASE EXPR_IS_WHILE
				WHILE TRUE
					self.ExecuteExpr(expr.expr)
					IF self.PopInt()
						LOCAL result% = self.ExecuteExpr(expr.Scp)
						SELECT result
							CASE EXECUTION_NORMAL
								// do nothing
							CASE EXECUTION_BREAK
								BREAK
							CASE EXECUTION_CONTINUE
								CONTINUE
							DEFAULT
								RETURN result
						ENDSELECT
					ELSE
						BREAK
					ENDIF
				WEND
			CASE EXPR_IS_REPEAT
				WHILE TRUE
					LOCAL result% = self.ExecuteExpr(expr.Scp)
					SELECT result
						CASE EXECUTION_NORMAL
								// do nothing
						CASE EXECUTION_BREAK
							BREAK
						CASE EXECUTION_CONTINUE
							CONTINUE
						DEFAULT
							RETURN result
					ENDSELECT
					
					self.ExecuteExpr(expr.expr)
					IF self.PopInt()
						BREAK
					ENDIF
				WEND
			CASE EXPR_IS_FOR
				self.ExecuteExpr(expr.varExpr)
				
				WHILE TRUE
					self.ExecuteExpr(Exprs[expr.varExpr].vari)
					LOCAL forCur = self.PopFloat()
					
					self.ExecuteExpr(expr.toExpr)
					LOCAL forTarget = self.PopFloat()
					
					self.ExecuteExpr(expr.stepExpr)
					LOCAL forStep = self.PopFloat()
					
					LOCAL cont%
					IF expr.hasTo
						SELECT forStep
							CASE >0
								cont = (forCur <= forTarget)
							CASE <0
								cont = (forCur >= forTarget)
							DEFAULT
								cont = NOT (forCur = forTarget) // <> buggy?!?!?
						ENDSELECT
					ELSE
						SELECT forStep
							CASE >0
								cont = (forCur < forTarget)
							CASE <0
								cont = (forCur > forTarget)
							DEFAULT
								cont = NOT (forCur = forTarget)
						ENDSELECT
					ENDIF
					
					IF cont
						LOCAL result% = self.ExecuteExpr(expr.Scp)
						SELECT result
							CASE EXECUTION_NORMAL
									// do nothing
							CASE EXECUTION_BREAK
								BREAK
							CASE EXECUTION_CONTINUE
								CONTINUE
							DEFAULT
								RETURN result
						ENDSELECT
						
						// increment/decrement counter
						self.ExecuteExpr(Exprs[expr.varExpr].vari)
						LOCAL var% = self.PopVar()
						ALIAS vari AS self.comp.Varis[var]
						
						self.ExecuteExpr(expr.stepExpr)
						
						self.PushFloat(self.PopFloat() + vari.Value.GetFloat(self))
						vari.Value = self.Stack[-1]
						self.Pop()
					ELSE
						BREAK
					ENDIF
				WEND
			CASE EXPR_IS_FOREACH
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_CONTINUE
				RETURN EXECUTION_CONTINUE
			CASE EXPR_IS_BREAK
				RETURN EXECUTION_BREAK
			CASE EXPR_IS_TRY
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_THROW
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_RESTORE
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_READ
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_DEFVAL
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_DIMASEXPR
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_ALIAS
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_GOTO
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_LABEL
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_INC
				// TODO: This should work with arrays too
				self.ExecuteExpr(expr.vari)
				LOCAL var% = self.PopVar()
				
				ALIAS vari AS self.comp.Varis[var]
				
				self.ExecuteExpr(expr.expr)
				
				self.PushFloat(self.PopFloat() + vari.Value.GetFloat(self))
				
				vari.Value = self.Stack[-1]
				self.Pop()
			CASE EXPR_IS_DIMPUSH
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_LEN
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_BOUND
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_DIMDATA
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_DELETE
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_DIMDEL
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_NOT
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_ADDRESSOF
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_ASSERT
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_DEBUGOUTPUT
				self.ExecuteExpr(expr.expr)
				DEBUG self.PopStr$()
			CASE EXPR_IS_IIF
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_REQUIRE
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_SUPER
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_CAST2OBJ
				Error("TODO Unimplemented Expr")
			CASE EXPR_IS_EMPTY
			CASE EXPR_IS_DEBUG
				Error("Invalid Expression")
			DEFAULT
				Error("Unknown expression type: "+expr.Typ)
		ENDSELECT
		
		RETURN EXECUTION_NORMAL
	ENDFUNCTION


	FUNCTION CallFunction: Name$, Params$[]

	ENDFUNCTION

	FUNCTION Init:
		self.comp = Compiler
	ENDFUNCTION
ENDTYPE

FUNCTION PrepareVari: vari AS IdentifierVari
	IF vari.Value.typ = 0
		SELECT vari.datatype.Name$
			CASE "int"
				IF vari.datatype.IsArray
					vari.Value.typ = STACKENTRY_INTARRAY
				ELSE
					vari.Value.typ = STACKENTRY_INT
				ENDIF
			CASE "float"
				IF vari.datatype.IsArray
					vari.Value.typ = STACKENTRY_FLOATARRAY
				ELSE
					vari.Value.typ = STACKENTRY_FLOAT
				ENDIF
			CASE "string"
				IF vari.datatype.IsArray
					vari.Value.typ = STACKENTRY_STRARRAY
				ELSE
					vari.Value.typ = STACKENTRY_STR
				ENDIF
			DEFAULT
				Error("Unknown Variable Type")
		ENDSELECT
	ENDIF
ENDFUNCTION

//! Generiert JavaScript Code
FUNCTION VM_Generator$:
	LOCAL Text$ = "YOLO"
	RETURN Text$
ENDFUNCTION


?ENDIF

